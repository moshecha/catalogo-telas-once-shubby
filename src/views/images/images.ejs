<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Subir Imagen — Catalogo Telas</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { background: #f6f7fb; padding: 2rem; }
    .card { border-radius: 12px; box-shadow: 0 6px 18px rgba(8,10,20,0.06); }
    .thumb { border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.08); margin: 6px; }
    .alert-container { position: fixed; top: 1rem; right: 1rem; z-index: 1080; width: 320px; }
  </style>
</head>
<body>
  <div class="container">
    <div class="row justify-content-center mb-4">
      <div class="col-md-8">
        <div class="card p-4">
          <h3 class="mb-3 text-center">Subir Imagen</h3>

          <div class="mb-3 d-flex gap-2 align-items-center">
            <input id="imageInput" type="file" accept="image/*" class="form-control" />
            <div class="vr"></div>
            <small class="text-muted">Máx: <span id="maxSizeText">0.9 MB</span></small>
          </div>

          <div id="previewBox" class="mb-3 d-flex flex-wrap"></div>

          <div class="mb-2">
            <div id="progressContainer" class="progress" style="height:12px; display:none;">
              <div id="progressBar" class="progress-bar" role="progressbar" style="width:0%"></div>
            </div>
          </div>

          <div class="text-center">
            <button id="refreshBtn" class="btn btn-outline-primary btn-sm">Recargar galería</button>
          </div>

        </div>
      </div>
    </div>

    <div class="row">
      <div class="col">
        <h5>Galería</h5>
        <div id="gallery" class="d-flex flex-wrap"></div>
      </div>
    </div>
  </div>

  <div class="alert-container" id="alerts"></div>

  <script>
  // CONFIG
  const MAX_SIZE_MB = 0.9;          // límite para subir (recomendado <1MB)
  const MAX_DIMENSION = 1200;       // píxeles máximo (mayor = más lenta)
  const PREFERRED_TYPE = 'image/webp';
  const PREFERRED_QUALITY = 0.78;   // calidad para toBlob
  const API_UPLOAD = '/images/api/upload';
  const API_LIST = '/images/api/getAllImages';

  // UTIL
  const alerts = document.getElementById('alerts');
  function showAlert(msg, type='success', timeout=5000) {
    const id = 'a' + Date.now();
    const el = document.createElement('div');
    el.className = `alert alert-${type} alert-dismissible fade show`;
    el.innerHTML = `<div>${msg}</div><button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>`;
    alerts.appendChild(el);
    if (timeout) setTimeout(()=>{ el.classList.remove('show'); el.classList.add('hide'); setTimeout(()=>el.remove(),350); }, timeout);
  }

  // FAST COMPRESSOR (client-side)
  async function fastCompress(file) {
    // if already small enough, keep it
    if (file.size / (1024*1024) <= MAX_SIZE_MB) return file;

    // createImageBitmap is faster on many browsers than new Image()
    let bitmap;
    try {
      bitmap = await createImageBitmap(file);
    } catch (err) {
      // fallback to FileReader / Image
      return await fallbackCompress(file);
    }

    // compute new dims (preserve aspect ratio)
    const ratio = Math.min(1, MAX_DIMENSION / Math.max(bitmap.width, bitmap.height));
    const w = Math.max(1, Math.round(bitmap.width * ratio));
    const h = Math.max(1, Math.round(bitmap.height * ratio));

    // Use OffscreenCanvas if available (faster & uses worker-like API)
    let blob;
    if (typeof OffscreenCanvas !== 'undefined') {
      const oc = new OffscreenCanvas(w, h);
      const ctx = oc.getContext('2d');
      ctx.drawImage(bitmap, 0, 0, w, h);
      blob = await oc.convertToBlob({ type: PREFERRED_TYPE, quality: PREFERRED_QUALITY });
    } else {
      const canvas = document.createElement('canvas');
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(bitmap, 0, 0, w, h);
      blob = await new Promise(res => canvas.toBlob(res, PREFERRED_TYPE, PREFERRED_QUALITY));
    }

    // If still big, try a second pass with lower quality
    if (blob.size / (1024*1024) > MAX_SIZE_MB) {
      blob = await new Promise(res => {
        const c = document.createElement('canvas'); c.width = w; c.height = h;
        const ctx = c.getContext('2d'); ctx.drawImage(bitmap, 0, 0, w, h);
        c.toBlob(res, PREFERRED_TYPE, 0.6);
      });
    }

    return new File([blob], file.name.replace(/\.[^.]+$/, '.webp'), { type: blob.type });
  }

  // fallback slower method
  function fallbackCompress(file) {
    return new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = async () => {
          let w = img.width, h = img.height;
          const ratio = Math.min(1, MAX_DIMENSION / Math.max(w, h));
          w = Math.round(w * ratio); h = Math.round(h * ratio);
          const canvas = document.createElement('canvas');
          canvas.width = w; canvas.height = h;
          const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0, w, h);
          canvas.toBlob(async (blob) => {
            if (blob.size / (1024*1024) > MAX_SIZE_MB) {
              canvas.toBlob(b => resolve(new File([b], file.name.replace(/\.[^.]+$/, '.webp'), { type: b.type })), PREFERRED_TYPE, 0.6);
            } else {
              resolve(new File([blob], file.name.replace(/\.[^.]+$/, '.webp'), { type: blob.type }));
            }
          }, PREFERRED_TYPE, PREFERRED_QUALITY);
        };
        img.src = reader.result;
      };
      reader.readAsDataURL(file);
    });
  }

  // UI & Upload
  const input = document.getElementById('imageInput');
  const previewBox = document.getElementById('previewBox');
  const progressContainer = document.getElementById('progressContainer');
  const progressBar = document.getElementById('progressBar');
  document.getElementById('maxSizeText').textContent = (MAX_SIZE_MB).toFixed(1) + ' MB';

  async function renderPreview(file) {
    previewBox.innerHTML = '';
    const url = URL.createObjectURL(file);
    const imgEl = document.createElement('img');
    imgEl.src = url;
    imgEl.className = 'thumb';
    imgEl.style.maxWidth = '180px';
    imgEl.style.maxHeight = '120px';
    previewBox.appendChild(imgEl);
  }

  async function doUpload(file) {
    try {
      showAlert('Preparando imagen...', 'info', 2000);
      const compressed = await fastCompress(file);

      // show preview of final file
      await renderPreview(compressed);

      const fd = new FormData();
      fd.append('image', compressed, compressed.name);

      // XMLHttpRequest for progress
      const xhr = new XMLHttpRequest();
      xhr.open('POST', API_UPLOAD, true);

      xhr.upload.onprogress = e => {
        if (e.lengthComputable) {
          progressContainer.style.display = 'block';
          const pct = Math.round((e.loaded / e.total) * 100);
          progressBar.style.width = pct + '%';
          progressBar.textContent = pct + '%';
        }
      };

      xhr.onload = () => {
        progressContainer.style.display = 'none';
        progressBar.style.width = '0%';
        if (xhr.status >= 200 && xhr.status < 300) {
          try {
            const json = JSON.parse(xhr.responseText || '{}');
            if (json.success) {
              showAlert('Imagen subida correctamente', 'success');
              loadGallery();
            } else {
              showAlert('Error al subir: ' + (json.message || 'server error'), 'danger');
            }
          } catch (e) {
            showAlert('Respuesta inválida del servidor', 'danger');
          }
        } else {
          showAlert('Error de subida: ' + xhr.status, 'danger');
        }
      };

      xhr.onerror = () => {
        progressContainer.style.display = 'none';
        showAlert('Error de conexión al subir', 'danger');
      };

      xhr.send(fd);

    } catch (err) {
      showAlert('Error procesando imagen: ' + (err.message || err), 'danger');
    }
  }

  input.addEventListener('change', async (e) => {
    if (!input.files || !input.files[0]) return;
    const f = input.files[0];
    if (!f.type.startsWith('image/')) return showAlert('Solo imágenes permitidas', 'warning');

    // perform upload (no extra user click)
    await doUpload(f);
    input.value = '';
  });

  document.getElementById('refreshBtn').addEventListener('click', loadGallery);

  async function loadGallery() {
    try {
      const res = await fetch(API_LIST);
      const json = await res.json();
      const gallery = document.getElementById('gallery');
      gallery.innerHTML = '';
      (json.data || []).forEach(u => {
        const img = document.createElement('img');
        img.src = u;
        img.width = 160;
        img.className = 'thumb';
        gallery.appendChild(img);
      });
    } catch (e) {
      showAlert('Error cargando galería', 'danger');
    }
  }

  // initial load
  loadGallery();
  </script>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
